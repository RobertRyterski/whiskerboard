# -*- coding: utf-8 -*-

from datetime import datetime, timedelta
import uuid
from django.template.defaultfilters import slugify
from mongoengine import Q
from mongoengine.document import Document
from mongoengine.document import EmbeddedDocument
from mongoengine.queryset import QuerySetManager
from mongoengine.fields import DateTimeField
from mongoengine.fields import EmbeddedDocumentField
from mongoengine.fields import ListField
from mongoengine.fields import StringField
from .models import STATUS_CODES, STATUS_DEFAULT


class Message(EmbeddedDocument):
    # id is used to keep SQL and API compatability
    id = StringField(default=lambda: uuid.uuid4().hex)
    status = StringField()
    message = StringField()
    timestamp = DateTimeField(default=lambda: datetime.utcnow())
    incident_id = StringField()  # In preparation for SQL compatability
    _default_manager = QuerySetManager()

    def __unicode__(self):
        return str(self.message)


class Incident(Document):
    service_ids = ListField(StringField(), db_field='sid')
    title = StringField(db_field='t')
    messages = ListField(EmbeddedDocumentField(Message), db_field='m')
    start_date = DateTimeField(db_field='s', default=lambda: datetime.utcnow())
    end_date = DateTimeField(db_field='e')
    created_date = DateTimeField(db_field='c',
                                 default=lambda: datetime.utcnow())
    _default_manager = QuerySetManager()

    def __unicode__(self):
        return str(self.title)

    def get_status(self, **kwargs):
        """
        Returns the status of the incident based on the status of the messages.

        Optional kwargs:
        time -- the datetime to determine the status of
                defaults to now

        Returns None if specified time is before any message.
        """
        # if they're aren't any messages, we don't have any status
        # shouldn't happen
        if len(self.messages) == 0:
            return None

        time = kwargs.pop('time', datetime.now())

        # assume messages are stored in chronological order
        # grab the latest message before the specified time
        for msg in reversed(self.messages):
            if msg.timestamp <= time:
                return msg.status

        # if we haven't returned, the time is out of range
        return None


class Service(Document):
    name = StringField(db_field='n')
    # Using string field for slug instead of URLField so form validation doesn't
    # fail, since this is an autogenerated field.
    slug = StringField(db_field='s')
    description = StringField(db_field='d')
    tags = StringField(db_field='c')
    created_date = DateTimeField(db_field='cd',
                                 default=lambda: datetime.utcnow())
    _default_manager = QuerySetManager()

    class Meta:
        ordering = ('name',)

    def save(self, *args, **kwargs):
        def make_slug(name):
            # For services with the same name, generate a unique slug
            slug = slugify(u'{0}'.format(name)).lower()
            slug_count = 1
            while not self.is_slug_available(slug):
                slug = u'{0}{1}'.format(slug, slug_count)
                slug_count += 1
            return slug

        if not self.id:
            self.slug = make_slug(self.name)

        super(Service, self).save(*args, **kwargs)

    def get_absolute_url(self):
        return self.slug

    @classmethod
    def is_slug_available(cls, slug):
        try:
            cls.objects.get(slug=slug)
            return False
        except cls.DoesNotExist:
            return True

    def __unicode__(self):
        return str(self.name)

    def get_current_incidents(self):
        return None

    def get_status(self, **kwargs):
        """
        Returns the highest status for a time from a set of incidents.

        Optional kwargs:
        incidents -- an iterable of incidents to use
                     defaults to current_incidents
        time -- the datetime to determine the status of
                defaults to now

        Note: This function doesn't care if passed incidents affect the current
                  service or not.
              If a time is passed outside the range of the incidents, None will
                  be returned.
        """
        time = kwargs.pop('time', datetime.now())
        incidents = kwargs.pop('incidents', self.get_current_incidents())

        # check 'cause it's possible not to have any current incidents
        if incidents is None:
            return None

        statuses = [i.get_status(time=time) for i in incidents]
        # 'cause having `if i.get_status() is not None` at the end looks ugly
        statuses = [s for s in statuses if s is not None]
        if len(statuses) == 0:
            return None
        highest = max(statuses, key=lambda x: STATUS_CODES[x][1])
        return highest

    def get_status_history(self, start=None, end=None):
        """
        Returns the status at the end of each day for the specified range.

        start -- datetime for chronological start of range
                 defaults to 5 days ago
        end -- datetime for chronological end of range
               defaults to 1 day ago
        """
        if start is None:
            start = datetime.today() - timedelta(days=5)
        if end is None:
            end = datetime.today() - timedelta(days=1)

        # make sure dates are at the very end
        start = start.replace(hour=23, minute=59, second=59, microsecond=999999)
        end = end.replace(hour=23, minute=59, second=59, microsecond=999999)

        # grab all impacting incidents for this range
        incidents = Incident.objects.filter(
            Q(service_ids=unicode(self.id)) &
            # event started before the end of this range
            Q(start_date__lte=end) &
            # event ended after the start of this range
            (Q(end_date__gte=start) | Q(end_date=None))
         )

        history = []
        while start <= end:
            # rely on get status
            status = self.get_status(time=start, incidents=incidents)
            history.append(status)
            start = start + timedelta(days=1)

        history.reverse()

        return history
